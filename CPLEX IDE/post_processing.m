%% Post-processing of Optimal solution
% $Author Dharini Dutia     `        $Created November 2018
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%% Initialization %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sheetname = 'my_sheet.xls';
%sheetname = 'oldHmin.xls';
%sheetname = 'oldHmax.xls';
%sheetname = 'oldHmax_signwrong.xls';
%sheetname = 'newHmin.xls';
%sheetname = 'newHmax.xls';

% Reading the solution generated by CPLEX IDE
xind = xlsread(sheetname, 'A1:A60');
xtime = xlsread(sheetname, 'B1:B60');


% other constants
tau = xlsread(sheetname, 'C1:C1');
R = xlsread(sheetname, 'C2:C2');

nodes = tau + 1;
R_vars = nodes^2 - nodes;
total_vars = (nodes^2 - nodes) *R;

dk = xlsread(sheetname, 'D1:D6');
task_start = xlsread(sheetname, 'E1:E6');
task_end = xlsread(sheetname, 'F1:F6');
time_taken = xlsread(sheetname, 'G1:L6');
g = xlsread(sheetname, 'M1:R6');

%%%%%%%%%%%%%%%%%%%%%%%%%%%% ordered decision tree %%%%%%%%%%%%%%%%%%%%%%%%
order = {};
temp = [];
%start pos = node 0
for r=1:R
    for i=1:nodes
        for j=1:nodes
            if i~=j
                if xind((r-1)*R_vars + (i-1)*tau + j) == 1
                    temp = [temp,j];
                end
            end
        end
        order{i,r} = temp;
        temp = [];
    end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% absolute time %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
arrival = zeros(nodes,R);
curr_node = 1;
next_node = 0;
visitation = zeros(nodes,2, R);
again = 0;

for r=1:R
    previous = 0;
    for count=1:nodes
        node_options = order{curr_node,r};
        [ro,c] = size(node_options);
        if ro~=0
            if ro >1 || c >1
                while next_node==0 || again == 1
                    % node selection based on shortest distance
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    comparison = time_taken(node_options);
                    % index of lowest distance
                    [n,n_id] = min(comparison);
                    next_node = node_options(n_id);
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    % node selection based on priority
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    %next_node = min(node_options);
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    again = 0;
                    
                    % if node already visited by the robot, find again
                    if (ismember(next_node,visitation(:,:,r)))
                        again = 1;
                        % remove repetition
                        node_options(node_options == next_node) = [];
                    end
                end
            else
                next_node = node_options;
            end
            
            id = (r-1)*R_vars + (curr_node-1)*tau + next_node;
            arrival(count,r) = previous + (task_end(next_node-1) - xtime(id,1)); %time_taken(curr_node,next_node)
            previous = arrival(count,r) + dk(next_node);
            
            visitation(count,:,r) = [curr_node, next_node];
            curr_node = next_node;
            next_node = 0;
        end
    end
end

% Printing arrival times
bundle1 = [visitation(:,:,1), arrival(:,1)]
bundle2 = [visitation(:,:,2), arrival(:,2)]




